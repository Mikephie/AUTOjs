
name: Script Conversion Workflow
on:
  workflow_dispatch:
    inputs:
      output_format:
        description: '转换输出格式'
        required: true
        default: 'loon'
        type: choice
        options:
          - loon
          - surge
  push:
    paths:
      - 'input/**'
  pull_request:
    paths:
      - 'input/**'
  schedule:
    - cron: '0 0 * * 0'  # 每周日UTC 00:00运行
jobs:
  convert:
    runs-on: ubuntu-latest
    name: 转换脚本
    permissions:
      contents: write  # 确保有写入内容的权限
    steps:
      - name: 检出代码
        uses: actions/checkout@v2
        with:
          fetch-depth: 0  # 获取完整历史记录，以便能够推送
          
      - name: 安装Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '16'
          
      - name: 创建输入输出目录
        run: |
          mkdir -p input
          mkdir -p output
          
      - name: 安装依赖
        run: |
          npm install @actions/core
          
      - name: 运行脚本转换
        id: converter
        run: |
          node index.js
        env:
          INPUT_DIR: 'input'
          OUTPUT_DIR: 'output'
          OUTPUT_FORMAT: ${{ github.event.inputs.output_format || 'loon' }}
          
      - name: 打包转换结果
        run: |
          tar -czvf converted-scripts.tar.gz output/
          echo "转换结果已打包为 converted-scripts.tar.gz"
          
      - name: 配置Git
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
      - name: 拉取最新更改
        run: |
          git pull --rebase origin main
          
      - name: 提交转换结果
        run: |
          git add output/ converted-scripts.tar.gz
          git commit -m "自动转换脚本 [$(date +'%Y-%m-%d %H:%M:%S')]" || echo "No changes to commit"
          git push
```

### 2. 脚本转换器 (script-converter.js)

```javascript
/**
 * 脚本转换器模块
 */

/**
 * 从文件内容中提取脚本内容
 * @param {string} content 文件内容
 * @returns {string} 提取的脚本内容
 */
function extractScriptContent(content) {
  // 移除注释和空行，保留核心脚本内容
  // 这是一个简单实现，可能需要根据实际脚本格式进行调整
  return content.trim();
}

/**
 * 解析脚本内容，提取元数据和主体
 * @param {string} content 脚本内容
 * @returns {Object} 解析后的脚本信息
 */
function parseScript(content) {
  // 基本的脚本信息提取
  const lines = content.split('\n');
  const metadata = {};
  const scriptBody = [];
  let inMetadata = false;
  
  // 尝试提取元数据（通常在注释中）
  for (const line of lines) {
    // 检测元数据格式，例如: // @name MyScript
    const metaMatch = line.match(/\/\/\s*@(\w+)\s+(.*)/);
    if (metaMatch) {
      const [, key, value] = metaMatch;
      metadata[key] = value.trim();
    } else if (!line.trim().startsWith('//')) {
      // 如果不是注释行，认为是脚本主体
      scriptBody.push(line);
    }
  }
  
  return {
    metadata,
    body: scriptBody.join('\n')
  };
}

/**
 * 转换为Loon格式
 * @param {Object} scriptInfo 脚本信息
 * @returns {string} Loon格式的脚本内容
 */
function convertToLoon(scriptInfo) {
  const { metadata, body } = scriptInfo;
  
  let result = `#!name=${metadata.name || 'Unknown Script'}\n`;
  result += `#!desc=${metadata.desc || metadata.description || '脚本描述未提供'}\n`;
  result += `#!author=${metadata.author || '未知作者'}\n`;
  result += `#!homepage=${metadata.homepage || ''}\n`;
  result += `#!icon=${metadata.icon || ''}\n\n`;
  
  // 添加脚本主体
  result += `[Script]\n`;
  
  // 如果有cron定义，添加定时任务
  if (metadata.cron) {
    result += `cron "${metadata.cron}" script-path=${metadata.name || 'script'}.js, tag=${metadata.name || 'script'}\n`;
  }
  
  // 如果有HTTP请求脚本
  if (metadata.http || metadata.mitm) {
    const pattern = metadata.pattern || '*';
    result += `http-response ${pattern} script-path=${metadata.name || 'script'}.js, requires-body=true, tag=${metadata.name || 'http-script'}\n`;
  }
  
  // 如果需要MITM
  if (metadata.mitm) {
    result += `\n[MITM]\n`;
    result += `hostname = ${metadata.mitm}\n`;
  }
  
  return result;
}

/**
 * 转换为Surge格式
 * @param {Object} scriptInfo 脚本信息
 * @returns {string} Surge格式的脚本内容
 */
function convertToSurge(scriptInfo) {
  const { metadata, body } = scriptInfo;
  
  let result = `#!name=${metadata.name || 'Unknown Script'}\n`;
  result += `#!desc=${metadata.desc || metadata.description || '脚本描述未提供'}\n`;
  result += `#!author=${metadata.author || '未知作者'}\n`;
  result += `#!homepage=${metadata.homepage || ''}\n`;
  result += `#!icon=${metadata.icon || ''}\n\n`;
  
  // 添加脚本主体
  result += `[Script]\n`;
  
  // 如果有cron定义，添加定时任务
  if (metadata.cron) {
    result += `${metadata.name || 'script'} = type=cron,cronexp="${metadata.cron}",script-path=${metadata.name || 'script'}.js\n`;
  }
  
  // 如果有HTTP请求脚本
  if (metadata.http || metadata.mitm) {
    const pattern = metadata.pattern || '*';
    result += `${metadata.name || 'http-script'} = type=http-response,pattern=${pattern},requires-body=1,script-path=${metadata.name || 'script'}.js\n`;
  }
  
  // 如果需要MITM
  if (metadata.mitm) {
    result += `\n[MITM]\n`;
    result += `hostname = %APPEND% ${metadata.mitm}\n`;
  }
  
  return result;
}

module.exports = {
  extractScriptContent,
  parseScript,
  convertToLoon,
  convertToSurge
};
```

### 3. 主脚本 (index.js)

```javascript
const core = require('@actions/core');
const fs = require('fs');
const path = require('path');
const converter = require('./script-converter');

async function run() {
  try {
    // 打印当前目录文件，用于调试
    console.log('当前目录文件:', fs.readdirSync('.'));
    
    // 获取Action输入参数
    const inputDir = process.env.INPUT_DIR || core.getInput('INPUT_DIR') || 'input';
    const outputDir = process.env.OUTPUT_DIR || core.getInput('OUTPUT_DIR') || 'output';
    const outputFormat = process.env.OUTPUT_FORMAT || core.getInput('OUTPUT_FORMAT') || 'loon';
    
    console.log(`开始处理脚本，输入目录: ${inputDir}，输出目录: ${outputDir}，输出格式: ${outputFormat}`);
    
    // 确保目录存在
    if (!fs.existsSync(inputDir)) {
      fs.mkdirSync(inputDir, { recursive: true });
      console.log(`创建输入目录: ${inputDir}`);
    }
    
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
      console.log(`创建输出目录: ${outputDir}`);
    }
    
    // 读取输入目录中的所有文件
    const files = fs.readdirSync(inputDir);
    const scriptFiles = files.filter(file => 
      file.endsWith('.js') || file.endsWith('.conf') || file.endsWith('.txt')
    );
    
    console.log(`发现 ${scriptFiles.length} 个脚本文件需要处理`);
    
    // 处理每个脚本文件
    const results = [];
    
    for (const file of scriptFiles) {
      try {
        console.log(`处理文件: ${file}`);
        
        const inputPath = path.join(inputDir, file);
        const outputExt = outputFormat.toLowerCase() === 'surge' ? '.sgmodule' : '.plugin';
        const outputFileName = `${path.basename(file, path.extname(file))}${outputExt}`;
        const outputPath = path.join(outputDir, outputFileName);
        
        // 读取文件内容
        const content = fs.readFileSync(inputPath, 'utf8');
        
        // 提取真正的脚本内容
        const scriptContent = converter.extractScriptContent(content);
        
        // 解析脚本
        const scriptInfo = converter.parseScript(scriptContent);
        
        // 根据目标格式生成配置
        let result;
        if (outputFormat.toLowerCase() === 'surge') {
          result = converter.convertToSurge(scriptInfo);
        } else {
          result = converter.convertToLoon(scriptInfo);
        }
        
        // 写入输出文件
        fs.writeFileSync(outputPath, result, 'utf8');
        
        console.log(`✅ ${file} -> ${outputFileName}`);
        results.push({
          file,
          success: true,
          outputFile: outputFileName
        });
      } catch (error) {
        console.error(`❌ 处理 ${file} 失败: ${error.message}`);
        results.push({
          file,
          success: false,
          error: error.message
        });
      }
    }
    
    // 统计结果
    const successCount = results.filter(r => r.success).length;
    const failCount = results.filter(r => !r.success).length;
    
    console.log(`处理结果:`);
    results.forEach(r => {
      if (r.success) {
        console.log(`✅ ${r.file} -> ${r.outputFile}`);
      } else {
        console.log(`❌ 处理 ${r.file} 失败: ${r.error}`);
      }
    });
    
    console.log(`处理结果: ${successCount} 成功, ${failCount} 失败, 共 ${results.length} 个文件`);
    
    // 设置Action输出（使用新的环境文件方式替代废弃的set-output）
    if (process.env.GITHUB_OUTPUT) {
      fs.appendFileSync(process.env.GITHUB_OUTPUT, `success_count=${successCount}\n`);
      fs.appendFileSync(process.env.GITHUB_OUTPUT, `fail_count=${failCount}\n`);
      fs.appendFileSync(process.env.GITHUB_OUTPUT, `total_count=${results.length}\n`);
    } else {
      // 兼容旧版本
      core.setOutput('success_count', successCount);
      core.setOutput('fail_count', failCount);
      core.setOutput('total_count', results.length);
    }
    
    // 如果有失败，设置警告
    if (failCount > 0) {
      core.warning(`有 ${failCount} 个脚本转换失败，请检查日志`);
    }
    
  } catch (error) {
    core.setFailed(`执行过程出错: ${error.message}`);
  }
}

run();
```

### 4. 包配置文件 (package.json)

```json
{
  "name": "script-converter",
  "version": "1.0.0",
  "description": "转换不同格式的脚本文件",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "script",
    "converter",
    "loon",
    "surge"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@actions/core": "^1.10.0"
  }
}
```

### 5. 示例脚本 (input/sample-loon-script.js)

```javascript
// @name 示例Loon脚本
// @desc 这是一个示例Loon脚本
// @author 示例作者
// @homepage https://example.com
// @icon https://example.com/icon.png
// @cron "0 9 * * *"
// @mitm example.com

console.log('这是一个示例Loon脚本');

function main() {
  // 脚本主体
  return 'Hello Loon!';
}

main();
```

### 6. 示例脚本 (input/sample-qx-script.js)

```javascript
// @name 示例QX脚本
// @desc 这是一个示例QX脚本
// @author 示例作者
// @homepage https://example.com
// @icon https://example.com/icon.png
// @http
// @pattern *.example.com
// @mitm example.com

console.log('这是一个示例QX脚本');

function main() {
  // 脚本主体
  return 'Hello QX!';
}

main();
